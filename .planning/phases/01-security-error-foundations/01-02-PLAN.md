---
phase: 01-security-error-foundations
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/security/exceptions.py
  - src/research/perplexity_client.py
  - src/research/anthropic_client.py
  - src/app.py
  - src/ui/web/server.py
  - src/research/suburb_discovery.py
  - src/research/suburb_research.py
autonomous: true

must_haves:
  truths:
    - "Catching a rate limit error routes to retry logic with retry_after metadata, without string matching"
    - "Catching an auth error routes to immediate failure with provider info, without string matching"
    - "Catching a timeout error routes to retry logic as a transient error, without string matching"
    - "All existing exception handlers in app.py and server.py catch the new exception types"
    - "Exceptions carry structured metadata (error_code, retry_after, is_transient, provider) accessible as attributes"
  artifacts:
    - path: "src/security/exceptions.py"
      provides: "ApplicationError hierarchy with structured metadata"
      contains: "class ApplicationError"
    - path: "src/research/perplexity_client.py"
      provides: "SDK exception wrapping into typed application exceptions"
      contains: "isinstance.*RateLimitError"
    - path: "src/research/anthropic_client.py"
      provides: "SDK exception wrapping into typed application exceptions"
      contains: "isinstance.*RateLimitError"
  key_links:
    - from: "src/security/exceptions.py"
      to: "src/research/perplexity_client.py"
      via: "import and raise of typed exceptions"
      pattern: "from.*security.*exceptions.*import"
    - from: "src/security/exceptions.py"
      to: "src/research/anthropic_client.py"
      via: "import and raise of typed exceptions"
      pattern: "from.*security.*exceptions.*import"
    - from: "src/security/exceptions.py"
      to: "src/app.py"
      via: "catch blocks using typed exceptions"
      pattern: "except.*RateLimitError|except.*AuthenticationError"
---

<objective>
Replace all string-matching error detection with a typed exception hierarchy carrying structured metadata, and migrate all existing error handlers to use the new types.

Purpose: Close ERR-01 through ERR-04 requirements -- create an ApplicationError base class with transient/permanent subclasses, wrap SDK exceptions into these types at the API client boundary, and update all catch blocks to dispatch on exception type instead of parsing error message strings.

Output: New `src/security/exceptions.py` with full exception hierarchy; migrated perplexity_client.py and anthropic_client.py using SDK-level isinstance checks; updated app.py and server.py imports and catch blocks.
</objective>

<execution_context>
@/Users/robertli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robertli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-error-foundations/01-RESEARCH.md
@.planning/phases/01-security-error-foundations/01-01-SUMMARY.md
@src/research/perplexity_client.py
@src/research/anthropic_client.py
@src/app.py
@src/ui/web/server.py
@src/research/suburb_discovery.py
@src/research/suburb_research.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception hierarchy with structured metadata</name>
  <files>
    src/security/exceptions.py
    src/security/__init__.py
  </files>
  <action>
**`src/security/exceptions.py`:**
Create a typed exception hierarchy:

```
ApplicationError (base)
  - error_code: str | None
  - retry_after: int | None  (seconds)
  - is_transient: bool
  - provider: str | None  ("perplexity" | "anthropic" | None)

  PermanentError(ApplicationError)  [is_transient=False]
    - ValidationError(PermanentError)     [error_code="VALIDATION_ERROR"]
      - field: str | None
    - AuthenticationError(PermanentError) [error_code="AUTH_ERROR"]
    - ConfigurationError(PermanentError)  [error_code="CONFIG_ERROR"]

  TransientError(ApplicationError)  [is_transient=True]
    - RateLimitError(TransientError)      [error_code="RATE_LIMIT", retry_after defaults to 60]
    - TimeoutError(TransientError)        [error_code="TIMEOUT"]
      - timeout_seconds: int
    - NetworkError(TransientError)        [error_code="NETWORK_ERROR"]
    - APIError(TransientError)            [error_code="API_ERROR"]
      - status_code: int | None

  ResearchError(ApplicationError)  [error_code="RESEARCH_ERROR"]
    - For errors specific to the research pipeline (e.g., JSON parse failure, no results)
```

Each exception class:
- Inherits from its parent and sets appropriate defaults for error_code and is_transient
- Accepts `message: str` as first arg plus keyword args for metadata
- `provider` is set on all API-related exceptions to indicate which provider caused the error
- `__str__` returns the message (no metadata in string representation to keep logs clean)
- All exceptions use `from e` chaining to preserve original traceback

Also create convenience constants:
- `TRANSIENT_ERRORS = (RateLimitError, TimeoutError, NetworkError, APIError)` tuple for catch blocks
- `PERMANENT_ERRORS = (AuthenticationError, ConfigurationError, ValidationError)` tuple for catch blocks
- `ACCOUNT_ERRORS = (RateLimitError, AuthenticationError)` tuple for account-level errors that should stop all workers

**`src/security/__init__.py`:**
Add exports for all new exception classes and convenience tuples.
  </action>
  <verify>
Run: `cd /Users/robertli/Desktop/local-projects/agentic-re-researcher && python -c "
import sys
sys.path.insert(0, 'src')
from security.exceptions import (
    ApplicationError, PermanentError, TransientError,
    ValidationError, AuthenticationError, ConfigurationError,
    RateLimitError, TimeoutError, NetworkError, APIError,
    ResearchError, TRANSIENT_ERRORS, PERMANENT_ERRORS, ACCOUNT_ERRORS
)

# Test hierarchy
rl = RateLimitError('Too fast', retry_after=30, provider='perplexity')
assert rl.is_transient == True
assert rl.retry_after == 30
assert rl.error_code == 'RATE_LIMIT'
assert rl.provider == 'perplexity'
assert isinstance(rl, TransientError)
assert isinstance(rl, ApplicationError)
print('RateLimitError OK')

auth = AuthenticationError('Bad key', provider='anthropic')
assert auth.is_transient == False
assert auth.error_code == 'AUTH_ERROR'
assert isinstance(auth, PermanentError)
print('AuthenticationError OK')

# Test catch with tuples
try:
    raise RateLimitError('test')
except TRANSIENT_ERRORS as e:
    print(f'Caught transient: {e.error_code}')

try:
    raise AuthenticationError('test')
except PERMANENT_ERRORS as e:
    print(f'Caught permanent: {e.error_code}')

try:
    raise RateLimitError('test')
except ACCOUNT_ERRORS as e:
    print(f'Caught account: {e.error_code}')

print('ALL CHECKS PASSED')
"
  </verify>
  <done>
    - ApplicationError base class with error_code, retry_after, is_transient, provider attributes
    - PermanentError and TransientError intermediate classes
    - Specific exception types: ValidationError, AuthenticationError, ConfigurationError, RateLimitError, TimeoutError, NetworkError, APIError, ResearchError
    - Convenience tuples TRANSIENT_ERRORS, PERMANENT_ERRORS, ACCOUNT_ERRORS for catch blocks
    - All exceptions support from-chaining and structured metadata
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate API clients and handlers to typed exceptions</name>
  <files>
    src/research/perplexity_client.py
    src/research/anthropic_client.py
    src/app.py
    src/ui/web/server.py
    src/research/suburb_discovery.py
    src/research/suburb_research.py
  </files>
  <action>
**`src/research/perplexity_client.py`:**
- Keep the existing `PerplexityAPIError`, `PerplexityRateLimitError`, `PerplexityAuthError` classes BUT make them subclass the new security.exceptions types:
  - `PerplexityAPIError(APIError)` -- with provider="perplexity"
  - `PerplexityRateLimitError(RateLimitError)` -- with provider="perplexity"
  - `PerplexityAuthError(AuthenticationError)` -- with provider="perplexity"
- In `call_deep_research()`, replace the string-matching error detection (lines 148-165) with SDK-level isinstance checks:
  - Try to import Perplexity SDK exception types. The perplexity SDK may throw exceptions with status codes or typed exceptions.
  - If SDK provides typed exceptions, use isinstance checks
  - If SDK only provides generic exceptions with status_code attribute, check `getattr(e, 'status_code', None)`:
    - 401, 403 -> raise PerplexityAuthError
    - 429 -> raise PerplexityRateLimitError with retry_after from response headers if available
    - 408, 504 -> raise TimeoutError
    - 500, 502, 503 -> raise PerplexityAPIError (transient)
  - FALLBACK ONLY: If exception has no status_code and is not a known SDK type, THEN and only then use string matching as last resort, but wrap in PerplexityAPIError
  - Extract `retry_after` from exception attributes (e.g., `e.headers.get('Retry-After')`) when available
- Sanitize error messages using `sanitize_text()` before including in exception messages (from Plan 01-01)

**`src/research/anthropic_client.py`:**
- Same pattern as perplexity_client.py:
  - `AnthropicAPIError(APIError)` with provider="anthropic"
  - `AnthropicRateLimitError(RateLimitError)` with provider="anthropic"
  - `AnthropicAuthError(AuthenticationError)` with provider="anthropic"
- The anthropic SDK (`import anthropic`) provides typed exceptions: `anthropic.RateLimitError`, `anthropic.AuthenticationError`, `anthropic.APIConnectionError`, `anthropic.APITimeoutError`, `anthropic.APIStatusError`
- Replace string matching (lines 152-169) with isinstance checks against these SDK types:
  - `except anthropic.RateLimitError as e:` -> raise AnthropicRateLimitError with retry_after
  - `except anthropic.AuthenticationError as e:` -> raise AnthropicAuthError
  - `except anthropic.APIConnectionError as e:` -> raise NetworkError
  - `except anthropic.APITimeoutError as e:` -> raise TimeoutError
  - `except anthropic.APIStatusError as e:` -> check status_code for 5xx -> raise AnthropicAPIError
  - `except Exception as e:` -> wrap in APIError as last resort
- All raised exceptions must use `from e` to preserve traceback chain

**`src/app.py`:**
- Update imports: replace individual PerplexityRateLimitError/PerplexityAuthError/etc imports with new hierarchy
- Update `API_CREDIT_AUTH_ERRORS` tuple to use `ACCOUNT_ERRORS` from security.exceptions
- Update `API_GENERAL_ERRORS` tuple to use `TRANSIENT_ERRORS` or keep provider-specific if needed
- Keep backward compatibility: existing catch blocks in `run_research_pipeline()` should work since PerplexityRateLimitError is now a subclass of RateLimitError. But update catch blocks to also handle the base types:
  - `except ACCOUNT_ERRORS` for account-level stop
  - `except TRANSIENT_ERRORS` for retry/skip
- Wrap any error messages passed to RunResult.error_message through `sanitize_text()`

**`src/ui/web/server.py`:**
- Same import updates as app.py
- Update the error tuple definitions to use the new hierarchy
- The global exception handler from Plan 01-01 already sanitizes -- ensure it also checks for ApplicationError subclasses to provide better error codes in responses

**`src/research/suburb_discovery.py` and `src/research/suburb_research.py`:**
- Update imports to use new exception types from security.exceptions
- The existing `AccountErrorSignal` pattern in suburb_discovery.py should continue working since PerplexityRateLimitError is now a subclass of RateLimitError
- Update any string-matching error detection in these files to use isinstance checks
  </action>
  <verify>
Run: `cd /Users/robertli/Desktop/local-projects/agentic-re-researcher && python -c "
import sys
sys.path.insert(0, 'src')

# Test that old exception names still work (backward compat via inheritance)
from research.perplexity_client import PerplexityRateLimitError, PerplexityAuthError, PerplexityAPIError
from research.anthropic_client import AnthropicRateLimitError, AnthropicAuthError, AnthropicAPIError
from security.exceptions import RateLimitError, AuthenticationError, APIError, ACCOUNT_ERRORS, TRANSIENT_ERRORS

# Verify inheritance
assert issubclass(PerplexityRateLimitError, RateLimitError), 'PerplexityRateLimitError must inherit RateLimitError'
assert issubclass(PerplexityAuthError, AuthenticationError), 'PerplexityAuthError must inherit AuthenticationError'
assert issubclass(AnthropicRateLimitError, RateLimitError), 'AnthropicRateLimitError must inherit RateLimitError'
assert issubclass(AnthropicAuthError, AuthenticationError), 'AnthropicAuthError must inherit AuthenticationError'
print('Inheritance OK')

# Verify structured metadata
e = PerplexityRateLimitError('test', retry_after=30)
assert e.provider == 'perplexity'
assert e.retry_after == 30
assert e.is_transient == True
print('Metadata OK')

# Verify catch with base types
try:
    raise PerplexityRateLimitError('test')
except ACCOUNT_ERRORS:
    print('Caught via ACCOUNT_ERRORS OK')

try:
    raise AnthropicRateLimitError('test')
except RateLimitError:
    print('Caught via base RateLimitError OK')

# Verify app.py imports work
from app import run_research_pipeline
print('app.py imports OK')

# Verify no string matching in clients
import inspect
pplx_src = inspect.getsource(sys.modules['research.perplexity_client'].PerplexityClient.call_deep_research)
assert 'error_str = str(e).lower()' not in pplx_src, 'String matching still present in perplexity_client'
print('No string matching in perplexity_client OK')

print('ALL CHECKS PASSED')
"
  </verify>
  <done>
    - PerplexityRateLimitError inherits from RateLimitError; PerplexityAuthError inherits from AuthenticationError
    - AnthropicRateLimitError inherits from RateLimitError; AnthropicAuthError inherits from AuthenticationError
    - API clients use SDK isinstance checks instead of string matching for error classification
    - All exceptions carry provider, error_code, retry_after, is_transient metadata
    - app.py and server.py catch blocks use typed exception hierarchy
    - Existing error handling behavior preserved through inheritance (no breaking changes)
    - Error messages sanitized before inclusion in responses
  </done>
</task>

</tasks>

<verification>
Phase success criteria addressed by this plan:
5. "Catching a rate limit error, a timeout, and an auth error each routes to different handling logic (retry vs fail vs stop) without string matching" -- typed exception hierarchy with isinstance checks replacing all string matching

Combined with Plan 01-01, all five Phase 1 success criteria are covered:
1. API keys never leak (01-01: sanitization)
2. Invalid regions rejected (01-01: whitelist validation)
3. Path traversal rejected (01-01: run_id and cache path validation)
4. Clear startup errors (01-01: validate_environment)
5. Type-based error routing (01-02: exception hierarchy)
</verification>

<success_criteria>
- `PerplexityRateLimitError('test').is_transient` returns True
- `AuthenticationError('test').is_transient` returns False
- `except RateLimitError` catches both `PerplexityRateLimitError` and `AnthropicRateLimitError`
- No `str(e).lower()` pattern exists in perplexity_client.py or anthropic_client.py error handling
- app.py catches `ACCOUNT_ERRORS` tuple instead of listing individual exception classes
- All exceptions preserve original traceback via `from e` chaining
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-error-foundations/01-02-SUMMARY.md`
</output>
