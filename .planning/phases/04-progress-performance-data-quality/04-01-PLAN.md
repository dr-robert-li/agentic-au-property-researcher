---
phase: 04-progress-performance-data-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - src/ui/web/server.py
  - src/app.py
  - src/ui/web/templates/run_status.html
autonomous: true

must_haves:
  truths:
    - "Browser shows live progress bar with percentage that updates without page refresh during a research run"
    - "SSE endpoint streams structured JSON events with message, percent, and timestamp fields"
    - "Closing browser tab and reopening reconnects to progress stream and shows current state"
    - "Client disconnect does not leak memory or leave orphan connections"
  artifacts:
    - path: "src/ui/web/server.py"
      provides: "SSE streaming endpoint at /api/progress/{run_id}/stream"
      contains: "EventSourceResponse"
    - path: "src/app.py"
      provides: "Progress callback with percentage tracking"
      contains: "percent"
    - path: "src/ui/web/templates/run_status.html"
      provides: "EventSource-based browser client replacing fetch polling"
      contains: "EventSource"
    - path: "requirements.txt"
      provides: "sse-starlette dependency"
      contains: "sse-starlette"
  key_links:
    - from: "src/app.py"
      to: "src/ui/web/server.py"
      via: "progress_callback(message, percent) pushes to queue.Queue with percent field"
      pattern: "progress_callback.*percent"
    - from: "src/ui/web/server.py"
      to: "src/ui/web/templates/run_status.html"
      via: "SSE endpoint streams events consumed by browser EventSource"
      pattern: "api/progress.*stream"
---

<objective>
Implement Server-Sent Events (SSE) for real-time progress streaming during research runs, replacing the current polling-based approach.

Purpose: Users currently see delayed progress updates due to 3-second polling intervals. SSE provides instant, push-based updates with a visual progress bar showing percentage completion.

Output: Working SSE endpoint, updated progress callback with percentage tracking, browser EventSource client with auto-reconnect.
</objective>

<execution_context>
@/Users/robertli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robertli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-progress-performance-data-quality/04-RESEARCH.md
@src/ui/web/server.py
@src/app.py
@src/ui/web/templates/run_status.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSE endpoint and progress callback with percentage</name>
  <files>
    requirements.txt
    src/ui/web/server.py
    src/app.py
  </files>
  <action>
1. Add `sse-starlette>=2.0.0` to requirements.txt and install it.

2. In `src/ui/web/server.py`:
   - Import: `from sse_starlette.sse import EventSourceResponse` and `import asyncio`
   - Add SSE connection tracking dict: `sse_connections: dict[str, set[asyncio.Task]] = {}` with `sse_connections_lock = threading.Lock()`
     - The set stores asyncio.Task objects representing active event_generator coroutines
     - This allows tracking of active SSE connections for cleanup
   - Create NEW endpoint `GET /api/progress/{run_id}/stream` that:
     - Gets progress_queue from `progress_queues.get(run_id)`
     - If no queue found, yields a single `{"event": "error", "data": json.dumps({"error": "Run not found"})}` and returns
     - Defines `async def event_generator()` that loops:
       - Checks `await request.is_disconnected()` to break on client disconnect
       - Uses `progress_queue.get_nowait()` in try/except `queue.Empty`
       - On message: yields `{"event": "progress", "data": json.dumps({"message": msg["message"], "percent": msg.get("percent", 0), "timestamp": msg["timestamp"]})}`
       - On `None` sentinel: yields `{"event": "complete", "data": json.dumps({"status": "completed"})}` and breaks
       - On Empty: yields `{"comment": "keepalive"}` and `await asyncio.sleep(0.5)`
     - Registers connection on entry:
       ```python
       current_task = asyncio.current_task()
       with sse_connections_lock:
           if run_id not in sse_connections:
               sse_connections[run_id] = set()
           sse_connections[run_id].add(current_task)
       ```
     - Removes in finally block:
       ```python
       with sse_connections_lock:
           if run_id in sse_connections:
               sse_connections[run_id].discard(current_task)
               if not sse_connections[run_id]:
                   del sse_connections[run_id]
       ```
     - Returns `EventSourceResponse(event_generator())`
   - Keep existing `/api/progress/{run_id}` polling endpoint as-is (backward compat)
   - Update `progress_callback` in `run_pipeline_background()` to accept both message and percent:
     ```python
     def progress_callback(message: str, percent: float = 0.0):
         try:
             progress_queue.put({"message": message, "percent": percent, "timestamp": datetime.now().isoformat()}, timeout=1)
         except queue.Full:
             pass
     ```

3. In `src/app.py`:
   - Update `progress_callback` type hint from `Callable[[str], None]` to `Callable[[str, float], None]` to make the contract explicit (not `Callable[..., None]` which loses type safety)
   - Update `_progress()` helper to accept and pass percent: `def _progress(message: str, percent: float = 0.0)`
   - Add percentage milestones throughout `run_research_pipeline()`:
     - Discovery start: `_progress("Starting suburb discovery...", 0)`
     - Discovery complete: `_progress(f"Found {len(candidates)} candidates", 20)`
     - Each research batch: calculate `percent = 20 + (60 * (i + 1) / total_batches)` and pass to `_progress`
     - Ranking: `_progress("Ranking suburbs...", 80)`
     - Report generation: `_progress("Generating reports...", 90)`
     - Complete: `_progress("Complete!", 100)`
   - Ensure all existing `_progress("message")` calls still work (percent defaults to 0.0)
  </action>
  <verify>
    - `pip install sse-starlette` succeeds
    - `python -c "from sse_starlette.sse import EventSourceResponse; print('OK')"` prints OK
    - `grep -n "EventSourceResponse" src/ui/web/server.py` finds the import and endpoint
    - `grep -n "percent" src/app.py` shows percentage tracking in pipeline stages
    - `grep -n "Callable\[\[str, float\], None\]" src/app.py` shows explicit type hint (not Callable[..., None])
    - `python -c "from src.app import run_research_pipeline; print('imports OK')"` succeeds (no syntax errors)
  </verify>
  <done>SSE endpoint exists at /api/progress/{run_id}/stream with connection tracking (set of asyncio.Task objects), progress_callback has explicit Callable[[str, float], None] signature, pipeline reports percentage at discovery (0-20%), research (20-80%), ranking (80-85%), reporting (85-100%)</done>
</task>

<task type="auto">
  <name>Task 2: Browser EventSource client with progress bar and auto-reconnect</name>
  <files>
    src/ui/web/templates/run_status.html
  </files>
  <action>
1. In `src/ui/web/templates/run_status.html`, replace the existing JavaScript polling logic (the `fetch('/api/progress/...')` + `setTimeout` pattern) with an EventSource-based client:

   ```javascript
   // Replace polling with SSE
   const runId = '{{ run_id }}';  // Keep existing template variable
   let eventSource = null;

   function connectSSE() {
       eventSource = new EventSource(`/api/progress/${runId}/stream`);

       eventSource.addEventListener('progress', function(e) {
           const data = JSON.parse(e.data);
           updateProgressBar(data.percent);
           addProgressMessage(data.message, data.timestamp);
       });

       eventSource.addEventListener('complete', function(e) {
           eventSource.close();
           // Redirect to results or reload to show final state
           setTimeout(() => window.location.reload(), 1000);
       });

       eventSource.addEventListener('error', function(e) {
           if (eventSource.readyState === EventSource.CLOSED) {
               // Server closed connection, try reconnect after delay
               setTimeout(connectSSE, 5000);
           }
           // EventSource auto-reconnects on network errors
       });
   }
   ```

2. Add a visual progress bar element to the HTML (if not already present). Use a simple CSS progress bar:
   - Container div with border and background
   - Inner div that changes width based on percent
   - Text overlay showing "XX%"
   - Style: height ~24px, rounded corners, green fill color (#28a745), transition: width 0.3s ease

3. Add `updateProgressBar(percent)` function:
   - Sets inner div width to `${percent}%`
   - Updates text to show `${Math.round(percent)}%`
   - Changes color at 100% to indicate completion

4. Keep `addProgressMessage(message, timestamp)` function to append messages to existing log area (preserve existing message display UI).

5. Add cleanup on page unload: `window.addEventListener('beforeunload', () => { if (eventSource) eventSource.close(); })`

6. Call `connectSSE()` on page load only if the run status indicates it's still in progress (check existing template condition like `{% if status == 'running' %}`).
  </action>
  <verify>
    - `grep -n "EventSource" src/ui/web/templates/run_status.html` finds the EventSource client code
    - `grep -n "progress-bar\|updateProgressBar" src/ui/web/templates/run_status.html` finds progress bar element and update function
    - `grep -n "beforeunload" src/ui/web/templates/run_status.html` confirms cleanup handler exists
    - No references to the old polling `setTimeout` or `setInterval` pattern remain in the SSE code path
  </verify>
  <done>Browser uses EventSource to receive live SSE events, displays a visual progress bar with percentage, auto-reconnects on disconnect, cleans up on page unload. Old polling code is replaced.</done>
</task>

</tasks>

<verification>
1. Start the server: `python -m src.app` -- no import errors
2. SSE endpoint exists: `curl -N -H "Accept: text/event-stream" http://localhost:8000/api/progress/test-run/stream` returns an error event (run not found) in SSE format
3. Progress callback signature supports percent parameter with explicit type hint
4. run_status.html contains EventSource client, progress bar, and cleanup handler
5. No regressions: existing /api/progress/{run_id} polling endpoint still functions
</verification>

<success_criteria>
- Browser shows live progress bar with percentage during research runs
- SSE events contain message, percent, and timestamp fields
- Tab close + reopen reconnects to stream automatically
- No memory leaks from SSE connections (cleanup in finally block)
</success_criteria>

<output>
After completion, create `.planning/phases/04-progress-performance-data-quality/04-01-SUMMARY.md`
</output>
